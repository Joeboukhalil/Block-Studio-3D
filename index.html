<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Grid Builder - Cubes, Spheres, Triangles</title>
<style>
body { margin: 0; overflow: hidden; background: #222; }
#ui {
  position: absolute; top: 10px; left: 10px; z-index: 10;
  background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px;
}
button { margin: 3px; padding: 5px 10px; }
</style>
</head>
<body>
<div id="ui">
  <button id="addCube">Add Cube</button>
  <button id="addSphere">Add Sphere</button>
  <button id="addTriangle">Add Triangle</button>
  <button id="placeShape">Place Shape</button>
  <br>
  <button id="up">Up</button>
  <button id="down">Down</button>
  <button id="left">Left</button>
  <button id="right">Right</button>
  <button id="deleteSelected">Delete Selected</button>
  <button id="undo">Undo Last</button>
  <button id="export">Export Model</button>
</div>
<canvas id="canvas"></canvas>

<script>
window.onload = function() {

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gridSize = 50;
let shapes = [];
let selectedShape = null;
let cameraDist = 600;
let angleX = -0.5, angleY = -0.5;
let offsetX = 0, offsetY = 0;
let isDragging = false, lastMouse = {x:0,y:0};

// 3D rotation
function rotate(x,y,z){
  let cosY = Math.cos(angleY), sinY = Math.sin(angleY);
  let dx = x*cosY - z*sinY;
  let dz = x*sinY + z*cosY;
  x=dx; z=dz;
  let cosX=Math.cos(angleX), sinX=Math.sin(angleX);
  let dy = y*cosX - z*sinX;
  z = y*sinX + z*cosX;
  y=dy;
  return {x,y,z};
}

// 3D to 2D projection
function project(v){
  let scale = cameraDist/(cameraDist - v.z);
  return { x: canvas.width/2 + (v.x+offsetX)*scale, y: canvas.height/2 - (v.y+offsetY)*scale };
}

// Draw shapes
function drawShape(s){
  if(s.type==='cube'){
    const s2=gridSize/2;
    const v = [
      {x:s.x-s2,y:s.y-s2,z:s.z-s2},{x:s.x+s2,y:s.y-s2,z:s.z-s2},
      {x:s.x+s2,y:s.y+s2,z:s.z-s2},{x:s.x-s2,y:s.y+s2,z:s.z-s2},
      {x:s.x-s2,y:s.y-s2,z:s.z+s2},{x:s.x+s2,y:s.y-s2,z:s.z+s2},
      {x:s.x+s2,y:s.y+s2,z:s.z+s2},{x:s.x-s2,y:s.y+s2,z:s.z+s2}
    ];
    const faces = [[0,1,2,3],[4,5,6,7],[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5]];
    const proj = v.map(p=>project(rotate(p.x,p.y,p.z)));
    ctx.fillStyle = s===selectedShape?'yellow':s.color;
    ctx.strokeStyle = '#000';
    faces.forEach(f=>{
      ctx.beginPath();
      ctx.moveTo(proj[f[0]].x, proj[f[0]].y);
      f.slice(1).forEach(i=>ctx.lineTo(proj[i].x, proj[i].y));
      ctx.closePath(); ctx.fill(); ctx.stroke();
    });
  }
  else if(s.type==='sphere'){
    const p = project(rotate(s.x,s.y,s.z));
    ctx.beginPath();
    ctx.arc(p.x,p.y, gridSize/2,0,Math.PI*2);
    ctx.fillStyle = s===selectedShape?'yellow':s.color;
    ctx.fill(); ctx.stroke();
  }
  else if(s.type==='triangle'){
    const s2=gridSize/2;
    const v=[
      {x:s.x,y:s.y+s2,z:s.z-s2},{x:s.x-s2,y:s.y-s2,z:s.z+s2},{x:s.x+s2,y:s.y-s2,z:s.z+s2}
    ];
    const proj=v.map(p=>project(rotate(p.x,p.y,p.z)));
    ctx.beginPath();
    ctx.moveTo(proj[0].x,proj[0].y);
    proj.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
    ctx.closePath();
    ctx.fillStyle = s===selectedShape?'yellow':s.color;
    ctx.fill(); ctx.stroke();
  }
}

// Draw grid
function drawGrid(){
  const count=20;
  ctx.strokeStyle='rgba(255,255,255,0.2)';
  for(let i=-count;i<=count;i++){
    let p1=project(rotate(i*gridSize,0,-count*gridSize));
    let p2=project(rotate(i*gridSize,0,count*gridSize));
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    let p3=project(rotate(-count*gridSize,0,i*gridSize));
    let p4=project(rotate(count*gridSize,0,i*gridSize));
    ctx.beginPath(); ctx.moveTo(p3.x,p3.y); ctx.lineTo(p4.x,p4.y); ctx.stroke();
  }
}

// Render loop
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  shapes.forEach(drawShape);
  if(selectedShape) drawShape(selectedShape); // Draw selected on top
  requestAnimationFrame(render);
}
render();

// Mouse rotation
canvas.addEventListener('mousedown', e=>{
  isDragging=true; lastMouse={x:e.clientX,y:e.clientY};
});
canvas.addEventListener('mouseup', e=>isDragging=false);
canvas.addEventListener('mousemove', e=>{
  if(isDragging){
    let dx=e.clientX-lastMouse.x, dy=e.clientY-lastMouse.y;
    angleY+=dx*0.01; angleX+=dy*0.01;
    lastMouse={x:e.clientX,y:e.clientY};
  }
});

// Zoom
canvas.addEventListener('wheel', e=>{
  cameraDist+=e.deltaY*0.5;
  if(cameraDist<100) cameraDist=100;
  if(cameraDist>2000) cameraDist=2000;
});

// Add shape
function addShape(type){
  let x=0, y=0, z=0;
  const column = shapes.filter(c=>c.x===x && c.z===z);
  z = column.length * gridSize; // vertical stacking
  const color = '#'+Math.floor(Math.random()*16777215).toString(16);
  const shape = {x, y, z, type, color};
  shapes.push(shape);       // add to shapes array
  selectedShape = shape;    // select for movement
}

// Buttons
document.getElementById('addCube').onclick = ()=>addShape('cube');
document.getElementById('addSphere').onclick = ()=>addShape('sphere');
document.getElementById('addTriangle').onclick = ()=>addShape('triangle');

document.getElementById('up').onclick = ()=>{if(selectedShape) selectedShape.z+=gridSize;};
document.getElementById('down').onclick = ()=>{if(selectedShape) selectedShape.z-=gridSize;};
document.getElementById('left').onclick = ()=>{if(selectedShape) selectedShape.x-=gridSize;};
document.getElementById('right').onclick = ()=>{if(selectedShape) selectedShape.x+=gridSize;};

document.getElementById('placeShape').onclick = ()=>{selectedShape=null;};

document.getElementById('deleteSelected').onclick = ()=>{
  if(selectedShape){
    const idx = shapes.indexOf(selectedShape);
    if(idx !== -1) shapes.splice(idx,1);
    selectedShape = null;
  }
};

document.getElementById('undo').onclick = ()=>{ shapes.pop(); };

document.getElementById('export').onclick = ()=>{
  const data = shapes.map(s=>({type:s.type,x:s.x,y:s.y,z:s.z,color:s.color}));
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download='3d_model.json';
  link.click();
};

// Resize
window.addEventListener('resize', ()=>{canvas.width=window.innerWidth;canvas.height=window.innerHeight;});

};
</script>
</body>
</html>